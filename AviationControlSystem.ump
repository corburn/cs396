// All units of measurement assume International Civil Aviation Organization standards

namespace aviationcontrolsystem;

class AviationControlSystem {
    public static void main(String[] args) {
        System.out.println("Initializing Aviation Control System Simulation");
        AviationControlSystem acs = new AviationControlSystem();
        
        AirTrafficControl here = new AirTrafficControl(50, "Here Name", "Here Place", new Pipeline(), new Pipeline());
        AirTrafficControl there = new AirTrafficControl(50, "There Name", "There Place", new Pipeline(), new Pipeline());
                
        acs.addAirport(here.getAirport());
        acs.addAirport(there.getAirport());
        
        Plane thePlane = new Plane("Risk", 666, "Mercury", "Firestorm", "CX7", 20000);
        Captain jackHarkness = new Captain();
        java.sql.Date now = new java.sql.Date(new Date().getTime());
        FlightPlan thePlan = new FlightPlan(jackHarkness, now, now, 95.0, thePlane, here.getAirport(), there.getAirport(), hereWeAre);
        thePlane.preFlightCheck();
      
        Terminal hereWeAre = new Terminal(here.getAirport());
        Terminal thereWeGo = new Terminal(there.getAirport());
        
        Passenger uno = new Passenger("Priest", 56, hereWeAre, thePlan);
        Passenger dos = new Passenger("Rabbi", 30, hereWeAre, thePlan);
        Passenger tres = new Passenger("Minister", 42, hereWeAre, thePlan);
        Passenger cuatro = new Passenger("StewieGriffin", 1, hereWeAre, thePlan);
      
        
        
        // TODO
        // - add pipelines to AirTrafficControl
        // - Plane adds itself to the takeoff pipeline
        // - AirTrafficControl state machine sees queue is not empty
        // - ATC checks all clear and grants clearance
        // - Plane takes off removing itself from the pipeline and reseting clearance
        // TODO
        // Figure out how/when ATC can reset clearance

        // The after() directives launch threads that continue to run after main has finished
        //System.out.println("End Simulation");
        //System.exit(0);
    }
    * -> * Airport;
}

class Captain {
    isA FlightDeckCrew;
}

// Captain, the pilot designated as the Pilot in command[1]
// Co-pilot, another pilot who is not the pilot in command,[1] normally called the First Officer.
// First officer, a pilot who is not the pilot in command.
// Second officer
// Third officer
// Flight engineer, on older aircraft they were the crew member responsible for engines, systems and fuel management.
interface FlightDeckCrew {
    //isA FlightCrew;
}

// Loadmaster, crew member on cargo aircraft responsible for loading freight and personnel and the weight and balance of the aircraft.
// Purser or Customer Service Manager is responsible for the cabin crew as a team leader.
// Flight attendant or Cabin Crew, crew member responsible for the safety of passengers.
interface CabinCrew {
    //isA FlightCrew;
}

// Regulations limit work hours and minimum rest hours
//interface FlightCrew {
//}

// maintenance, fueling, luggage, etc
interface GroundCrew {
}

class Airline {
    0..1 -- 1..* Plane;
    name;
}

class Airport {
    1 -- 1 AirTrafficControl;
    1 -- 1..* Runway;
    immutable name;
    immutable address;
    // altitude in feet
    //immutable int altitude;
    // TODO close airport
    lazy boolean isEmergency;
}

// Criticism: the assignment specification requires every airport have a control unit,
// however, not all airports will have a control unit in which case a unit would have
// authority over a region.
class AirTrafficControl {
    * -> 2 Pipeline;
    // TODO
    // Aircraft should be able to request hazards information such as weather
    // (rain, ice, fog (range of visibility), wind gusts (direction, speed, etc)

    // Operating range in Nautical Miles
    int range;
    // TODO
    // To enter a pipeline state, the plane calls this method to add itself to the queue.
    // In the below state machine, the request is granted when the plane is assigned to a runway
    public void requestTakeoffClearance(Plane plane) {
        getPipeline(0).addPlane(plane);
    }
    public void requestLandingClearance(Plane plane) {
        getPipeline(1).addPlane(plane);
    }
    private void assignRunway() {
    }
    // TODO
    // The plane calls this method after/during takeoff to indicate the runway is available again
    public void acknowledgeClearance(Plane plane) {
        
    }
    queued airspace {
        // TODO
        // The intended implementation is that it should idle in the MonitorAirspace state
        // with a [hasPlanesInPipeline] Guard condition to a pipeline where a single request
        // is handled before returning to the MonitorAirspace state.
        // while(hasPlanesInPipeline) {
        //    handleRequest()
        // }
        Monitor {
            entry / {
                System.out.println(getAirport().getName() + " Air Traffic Control entering Monitor");
            }
            // Handle each request until the pipeline is empty
            [getPipeline(0).hasPlanes()] -> TakeoffPipeline;
            requestTakeoffClearance() -> TakeoffPipeline;
            [getPipeline(1).hasPlanes()] -> LandingPipeline;
            requestLandingClearance() -> LandingPipeline;
        }
        TakeoffPipeline {
            entry / {
                System.out.println(getAirport().getName() + " Air Traffic Control entering TakeoffPipeline");
            }
            -> Monitor;
        }
        LandingPipeline {
            entry / {
                System.out.println(getAirport().getName() + " Air Traffic Control entering LandingPipeline");
            }
            -> Monitor;
        }
    }
}

class Baggage {
}

class FlightPlan {
    // origin and destination
    * -- 2 Airport;
    * -> * CabinCrew;
    * -> * FlightDeckCrew;
    // At least one of the FlightDeckCrew must be a Captain
    Captain captain;
    // Discovered UMPLE imports java.sql.Date when trying to define
    // depend java.util.Date
    // Departure and arrival times
    Date start;
    Date end;
    // Minimum gallons of fuel required to complete the flight
    // TODO implement guard conditions to prevent flight with insufficient fuel
    double minFuel;
}

class Passenger {
    * -- 1..* FlightPlan;
    1 -- * Baggage;
    name;
    int age;
}

class Pipeline {
    * -> * Plane;
}

class Plane {
    // TODO cancel/modify FlightPlan
    1 -- * FlightPlan;
    // Aircraft Registration
    immutable registration;
    immutable int seats;
    immutable make;
    immutable model;
    immutable series;
    // Unscheduled general aviation will generally use registration
    // Commercial operators will use ICAO airline designator and route number
    flightCode = registration;
    // Defaults to flight code but may be reassigned by Air Traffic Control
    defaulted callsign = flightCode;
    // Gallons of fuel in the tanks
    // TODO fuel min / max guards
    // Cannot have negative fuel or exceed capacity
    // TODO define fuel capacity
    lazy double fuel;
    lazy boolean isEmergency;
    // TODO remove and use AirTrafficControl request / acknowledge clearance
    lazy boolean isCleared;
    // Weather deposits ice on the control surfaces
    lazy boolean hasIce;
    // TODO altitude should initialize to altitude of current airport
    int altitude;
    // A crude function to print the entry, action, and exit state transitions
    private void printTransition(String event, String state) {
        System.out.println("Flight " + getCallsign() + " " + event + " " + state);
    }
  
    private boolean hasPassengersAtTerminal() {
        return getFlightPlan(0).getTerminal(0).hasPassengers();
    }
    private void board() {
        FlightPlan plan = getFlightPlan(0);
        Terminal terminal = plan.getTerminal(0);
        List<Passenger> passengers = terminal.getPassengers();
        for(Passenger passenger : passengers) {
            plan.addPassenger(passenger);
            terminal.removePassenger(passenger);
        }
    }
    private void disembark(int terminal) {
        Terminal awesomeTerminal = getFlightPlan(0).getTerminal(terminal);
        FlightPlan awesomePlan = getFlightPlan(0);
        List<Passenger> morePassengers = awesomePlan.getPassengers();
      for (Passenger passenger : morePassengers) {
          awesomeTerminal.addPassenger(passenger);
          awesomePlan.removePassenger(passenger);
      }
    }
    // TODO handle emergencies (flight, passenger, etc)
    // Add declareEmergency() function and appropriate transition to all states.
    // Add [isEmergency] guarded auto transition to all state to handle emergency
    // declared in any earlier state.
    flight {
        Standby {
            entry / {
                printTransition("entering", "Standby");
            }
            // TODO: add has FlightPlan *today* Guard
            preFlightCheck() [hasFlightPlans()] -> PreFlight;
        }
        PreFlight {
            entry / {
                printTransition("entering", "PreFlight");
            }
            // TODO Guard AirTrafficControl approve (check isValid) FlightPlan
            isFlightReady() [!hasPassengersAtTerminal()] -> FlightPrep;
            isFlightReady() [hasPassengersAtTerminal()] -> Board;
        }
        Board {
            entry / {
                printTransition("entering", "Board");
                board();
            }
            [isEmergency] -> Disembark;
            // TODO AirTrafficControl.requestClearance(this);
            [!isEmergency] -> FlightPrep;
        }
        FlightPrep {
            entry / {
                printTransition("entering", "FlightPrep");
            }
            -> TakeoffPipeline;
        }
        TakeoffPipeline {
            entry / {
                printTransition("entering", "TakeoffPipeline");
            }
            Ready {
                entry / {
                    printTransition("entering", "Ready");
                }
                [hasIce] -> DeIce;
            }
            DeIce {
                entry / {
                    printTransition("entering", "DeIce");
                }
                // Aircraft must takeoff within the deicing fluid holdover or else wait
                // to be deiced again
                //
                // TODO the holdover period should be a constant defined by the
                // AviationControlSystem. Magic numbers buried in the code are bad practice.
                // 15 minutes
                after(15*60) [hasIce] -> DeIce;
            }
            // Before a flight can land or takeoff, an explicit permission must be issued
            // that expires after a set amount of time
            //
            // 60 minutes (arbitrary)
            // CRITICISM have to hard code plane timeout, does not work with generated get methods
            after(60*60) [!isCleared] / {
                printTransition("transition", "TakeoffPipeline -> TakeoffPrep");
            } -> FlightPrep;
            // TODO replace with AirTrafficControl.acknowledgeClearance(Plane);
            // 'rotate' is jargon for when an aircraft lifts up from the runway
            rotate() / {
                printTransition("transition", "TakeoffPipeline -> Transit");
            } -> Transit;
        }
        Transit {
            entry / {
                printTransition("entering", "Transit");
            }
            // TODO
            // Add transitions between AirTrafficControllers en route as the aircraft
            // enters/leaves their airspace
            -> LandingPipeline;
        }
        LandingPipeline {
            entry / {
                printTransition("entering", "LandingPipeline");
            }
            land() [isCleared] -> Disembark;
        }
        // TODO handle Missing In Action / Crash states
        Disembark {
            entry / {
                // Any landing you walk away from is a good landing
                printTransition("entering", "Disembark");
            }
            -> Standby;
            exit / {
                // Remove the completed FlightPlan from the queue
                // TODO: use the sorted directive to make sure flights are sorted by Date
                removeFlightPlan(getFlightPlan(0));                
            }
        }
    }
}

class Runway {
    * -> * GroundCrew;
    int capacity;
    //int id;
    boolean isLatitudinal;
  runwayState2 {
  
    Open {
      crisis -> EmergencyShutdown;
      
      Available {
        planeDeparting -> InUse;
		planeJustLanded -> InUse;
        repair -> Reconstruction;
		weather -> Reconstruction;
      }
      
      InUse {
        planeDeparted -> Available;
        planeReachesTerminal -> Available;
      }
    }
  
    Closed {
      EmergencyShutdown {
        crisisResolved -> RunwaySafe;
      }
      
      RunwaySafe {
        opening -> Open;
      }
      
      Reconstruction {
          Repair {
            completed -> Inspect;
          }
          Inspect { 
            upToStandard -> RunwaySafe;
            notUpToStandard -> Repair; 
          }
      }
    } 
  }
    direction {
        Undefined {
            [isLatitudinal] -> North;
            [!isLatitudinal] -> East;
        }
        North {
            changeDirection() -> South;
        }
        South {
            changeDirection() -> North;
        }
        East {
            changeDirection() -> West;
        }
        West {
            changeDirection() -> East;
        }
    }
}

class Terminal {
  * -- 1 Airport;
  1 -- * Passenger;
  2 -- * FlightPlan;
}
